Index: ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsEmerald.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * Copyright (c) SpaceToad, 2011\n * http://www.mod-buildcraft.com\n *\n * BuildCraft is distributed under the terms of the Minecraft Mod Public\n * License 1.0, or MMPL. Please check the contents of the license located in\n * http://www.mod-buildcraft.com/MMPL-1.0.txt\n */\npackage buildcraft.transport.pipes;\n\nimport buildcraft.BuildCraftTransport;\nimport buildcraft.api.inventory.ISelectiveInventory;\nimport net.minecraft.inventory.IInventory;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.world.World;\nimport net.minecraftforge.common.ForgeDirection;\nimport net.minecraftforge.common.ISidedInventory;\nimport buildcraft.api.inventory.ISpecialInventory;\nimport buildcraft.core.GuiIds;\nimport buildcraft.core.network.IClientState;\nimport buildcraft.core.proxy.CoreProxy;\nimport buildcraft.core.utils.SimpleInventory;\nimport buildcraft.core.utils.Utils;\nimport buildcraft.transport.BlockGenericPipe;\nimport buildcraft.transport.PipeTransportItems;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.nbt.NBTBase;\nimport net.minecraft.nbt.NBTTagCompound;\n\npublic class PipeItemsEmerald extends PipeItemsWood implements IInventory, ISpecialInventory, IClientState {\n\n\tprivate SimpleInventory filters = new SimpleInventory(9, \"items\", 1);\n\tprivate int currentFilter = 0;\n\n\tprotected PipeItemsEmerald(int itemID, PipeTransportItems transport) {\n\t\tsuper(transport, new PipeLogicEmerald(), itemID);\n\n\t\tbaseTexture = 6 * 16 + 13;\n\t\tplainTexture = baseTexture + 1;\n\t}\n\n\tpublic PipeItemsEmerald(int itemID) {\n\t\tthis(itemID, new PipeTransportItems());\n\t}\n\n\t@Override\n\tpublic boolean blockActivated(World world, int x, int y, int z, EntityPlayer entityplayer) {\n\t\tif (entityplayer.getCurrentEquippedItem() != null && entityplayer.getCurrentEquippedItem().itemID < Block.blocksList.length) {\n\t\t\tif (Block.blocksList[entityplayer.getCurrentEquippedItem().itemID] instanceof BlockGenericPipe) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (super.blockActivated(worldObj, x, y, z, entityplayer)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!CoreProxy.proxy.isRenderWorld(container.worldObj)) {\n\t\t\tentityplayer.openGui(BuildCraftTransport.instance, GuiIds.PIPE_EMERALD_ITEM, worldObj, x, y, z);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return the itemstack that can be if something can be extracted from this\n\t * inventory, null if none. On certain cases, the extractable slot depends\n\t * on the position of the pipe.\n\t */\n\t@Override\n\tpublic ItemStack[] checkExtract(IInventory inventory, boolean doRemove, ForgeDirection from) {\n\n\t\t// ISELECTIVEINVENTORY\n\t\tif (inventory instanceof ISelectiveInventory) {\n\t\t\tItemStack[] stacks = ((ISelectiveInventory) inventory).extractItem(new ItemStack[]{getCurrentFilter()}, false, doRemove, from, (int) getPowerProvider().getEnergyStored());\n\t\t\tif (doRemove) {\n\t\t\t\tfor (ItemStack stack : stacks) {\n\t\t\t\t\tif (stack != null) {\n\t\t\t\t\t\tgetPowerProvider().useEnergy(stack.stackSize, stack.stackSize, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tincrementFilter();\n\t\t\t}\n\t\t\treturn stacks;\n\t\t}\n\n\n\t\t// ISPECIALINVENTORY\n\t\tif (inventory instanceof ISpecialInventory) {\n\t\t\tItemStack[] stacks = ((ISpecialInventory) inventory).extractItem(false, from, (int) getPowerProvider().getEnergyStored());\n\t\t\tif (stacks != null) {\n\t\t\t\tfor (ItemStack stack : stacks) {\n\t\t\t\t\tboolean matches = false;\n\t\t\t\t\tfor (int i = 0; i < filters.getSizeInventory(); i++) {\n\t\t\t\t\t\tItemStack filter = filters.getStackInSlot(i);\n\t\t\t\t\t\tif (filter != null && filter.isItemEqual(stack)) {\n\t\t\t\t\t\t\tmatches = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (doRemove) {\n\t\t\t\t\tstacks = ((ISpecialInventory) inventory).extractItem(true, from, (int) getPowerProvider().getEnergyStored());\n\t\t\t\t\tfor (ItemStack stack : stacks) {\n\t\t\t\t\t\tif (stack != null) {\n\t\t\t\t\t\t\tgetPowerProvider().useEnergy(stack.stackSize, stack.stackSize, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stacks;\n\t\t}\n\n\t\tif (inventory instanceof ISidedInventory) {\n\t\t\tISidedInventory sidedInv = (ISidedInventory) inventory;\n\n\t\t\tint first = sidedInv.getStartInventorySide(from);\n\t\t\tint last = first + sidedInv.getSizeInventorySide(from) - 1;\n\n\t\t\tIInventory inv = Utils.getInventory(inventory);\n\n\t\t\tItemStack result = checkExtractGeneric(inv, doRemove, from, first, last);\n\n\t\t\tif (result != null) {\n\t\t\t\treturn new ItemStack[]{result};\n\t\t\t}\n\t\t} else {\n\t\t\t// This is a generic inventory\n\t\t\tIInventory inv = Utils.getInventory(inventory);\n\n\t\t\tItemStack result = checkExtractGeneric(inv, doRemove, from, 0, inv.getSizeInventory() - 1);\n\n\t\t\tif (result != null) {\n\t\t\t\treturn new ItemStack[]{result};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void incrementFilter() {\n\t\tcurrentFilter++;\n\t\tint count = 0;\n\t\twhile (filters.getStackInSlot(currentFilter % filters.getSizeInventory()) == null && count < filters.getSizeInventory()) {\n\t\t\tcurrentFilter++;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tprivate ItemStack getCurrentFilter() {\n\t\tItemStack filter = filters.getStackInSlot(currentFilter % filters.getSizeInventory());\n\t\tif (filter == null) {\n\t\t\tincrementFilter();\n\t\t}\n\t\treturn filters.getStackInSlot(currentFilter % filters.getSizeInventory());\n\t}\n\n\t@Override\n\tpublic ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int start, int stop) {\n\t\tfor (int i = start; i <= stop; ++i) {\n\t\t\tItemStack stack = inventory.getStackInSlot(i);\n\t\t\tif (stack != null && stack.stackSize > 0) {\n\t\t\t\tItemStack filter = getCurrentFilter();\n\t\t\t\tif (filter == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (!filter.isItemEqual(stack)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (doRemove) {\n\t\t\t\t\tincrementFilter();\n\t\t\t\t\treturn inventory.decrStackSize(i, (int) getPowerProvider().useEnergy(1, stack.stackSize, true));\n\t\t\t\t} else {\n\t\t\t\t\treturn stack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/* SAVING & LOADING */\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound nbttagcompound) {\n\t\tsuper.readFromNBT(nbttagcompound);\n\t\tfilters.readFromNBT(nbttagcompound);\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound nbttagcompound) {\n\t\tsuper.writeToNBT(nbttagcompound);\n\t\tfilters.writeToNBT(nbttagcompound);\n\t}\n\n\t// ICLIENTSTATE\n\t@Override\n\tpublic void writeData(DataOutputStream data) throws IOException {\n\t\tNBTTagCompound nbt = new NBTTagCompound();\n\t\twriteToNBT(nbt);\n\t\tNBTBase.writeNamedTag(nbt, data);\n\t}\n\n\t@Override\n\tpublic void readData(DataInputStream data) throws IOException {\n\t\tNBTBase nbt = NBTBase.readNamedTag(data);\n\t\tif (nbt instanceof NBTTagCompound) {\n\t\t\treadFromNBT((NBTTagCompound) nbt);\n\t\t}\n\t}\n\n\t/* ISPECIALINVENTORY */\n\t@Override\n\tpublic int addItem(ItemStack stack, boolean doAdd, ForgeDirection from) {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic ItemStack[] extractItem(boolean doRemove, ForgeDirection from, int maxItemCount) {\n\t\treturn new ItemStack[0];\n\t}\n\n\t/* IINVENTORY IMPLEMENTATION */\n\t@Override\n\tpublic int getSizeInventory() {\n\t\treturn filters.getSizeInventory();\n\t}\n\n\t@Override\n\tpublic ItemStack getStackInSlot(int i) {\n\t\treturn filters.getStackInSlot(i);\n\t}\n\n\t@Override\n\tpublic String getInvName() {\n\t\treturn \"Filters\";\n\t}\n\n\t@Override\n\tpublic int getInventoryStackLimit() {\n\t\treturn filters.getInventoryStackLimit();\n\t}\n\n\t@Override\n\tpublic ItemStack getStackInSlotOnClosing(int i) {\n\t\treturn filters.getStackInSlotOnClosing(i);\n\t}\n\n\t@Override\n\tpublic void onInventoryChanged() {\n\t\tfilters.onInventoryChanged();\n\t}\n\n\t@Override\n\tpublic boolean isUseableByPlayer(EntityPlayer var1) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void openChest() {\n\t}\n\n\t@Override\n\tpublic void closeChest() {\n\t}\n\n\t@Override\n\tpublic ItemStack decrStackSize(int i, int j) {\n\t\tItemStack stack = filters.decrStackSize(i, j);\n\n\t\tif (CoreProxy.proxy.isSimulating(worldObj)) {\n\t\t\tworldObj.markBlockForUpdate(xCoord, yCoord, zCoord);\n\t\t}\n\n\t\treturn stack;\n\t}\n\n\t@Override\n\tpublic void setInventorySlotContents(int i, ItemStack itemstack) {\n\n\t\tfilters.setInventorySlotContents(i, itemstack);\n\t\tif (CoreProxy.proxy.isSimulating(worldObj)) {\n\t\t\tworldObj.markBlockForUpdate(xCoord, yCoord, zCoord);\n\t\t}\n\n\t}\n}\n
===================================================================
--- ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsEmerald.java	(date 1359853860000)
+++ ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsEmerald.java	(revision )
@@ -30,6 +30,8 @@
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
+import net.minecraftforge.inventory.IInventoryHandler;
+import net.minecraftforge.inventory.InventoryUtils;
 
 public class PipeItemsEmerald extends PipeItemsWood implements IInventory, ISpecialInventory, IClientState {
 
@@ -164,6 +166,7 @@
 
 	@Override
 	public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int start, int stop) {
+		IInventoryHandler handler = InventoryUtils.getInventoryHandler(inventory);
 		for (int i = start; i <= stop; ++i) {
 			ItemStack stack = inventory.getStackInSlot(i);
 			if (stack != null && stack.stackSize > 0) {
@@ -171,12 +174,14 @@
 				if (filter == null) {
 					return null;
 				}
-				if (!filter.isItemEqual(stack)) {
+				int count = handler.getItemCountInSlot(inventory, i, filter);
+				if (count <= 0) {
 					continue;
 				}
 				if (doRemove) {
 					incrementFilter();
-					return inventory.decrStackSize(i, (int) getPowerProvider().useEnergy(1, stack.stackSize, true));
+					getPowerProvider().useEnergy(1, stack.stackSize, true);
+					return handler.takeItemFromInventorySlot(inventory, i);
 				} else {
 					return stack;
 				}
