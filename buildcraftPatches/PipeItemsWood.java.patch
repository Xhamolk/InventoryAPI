Index: ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsWood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * BuildCraft is open-source. It is distributed under the terms of the\n * BuildCraft Open Source License. It grants rights to read, modify, compile\n * or run the code. It does *NOT* grant the right to redistribute this software\n * or its modifications in any form, binary or source, except if expressively\n * granted by the copyright holder.\n */\n\npackage buildcraft.transport.pipes;\n\nimport net.minecraft.inventory.IInventory;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.world.World;\nimport net.minecraftforge.common.ForgeDirection;\nimport net.minecraftforge.common.ISidedInventory;\nimport buildcraft.api.core.Position;\nimport buildcraft.api.inventory.ISpecialInventory;\nimport buildcraft.api.power.IPowerProvider;\nimport buildcraft.api.power.IPowerReceptor;\nimport buildcraft.api.power.PowerFramework;\nimport buildcraft.api.transport.IPipedItem;\nimport buildcraft.api.transport.PipeManager;\nimport buildcraft.core.DefaultProps;\nimport buildcraft.core.EntityPassiveItem;\nimport buildcraft.core.RedstonePowerFramework;\nimport buildcraft.core.utils.Utils;\nimport buildcraft.transport.Pipe;\nimport buildcraft.transport.PipeTransportItems;\n\npublic class PipeItemsWood extends Pipe implements IPowerReceptor {\n\n\tprivate IPowerProvider powerProvider;\n\n\tprotected int baseTexture = 1 * 16 + 0;\n\tprotected int plainTexture = 1 * 16 + 15;\n\n\tprotected PipeItemsWood(PipeTransportItems transport, PipeLogic logic, int itemID) {\n\t\tsuper(transport, logic, itemID);\n\n\t\tpowerProvider = PowerFramework.currentFramework.createPowerProvider();\n\t\tpowerProvider.configure(50, 1, 64, 1, 64);\n\t\tpowerProvider.configurePowerPerdition(64, 1);\n\t}\n\t\n\tprotected PipeItemsWood(int itemID, PipeTransportItems transport) {\n\t\tthis(transport, new PipeLogicWood(), itemID);\n\t}\n\n\tpublic PipeItemsWood(int itemID) {\n\t\tthis(itemID, new PipeTransportItems());\n\t}\n\n\t@Override\n\tpublic String getTextureFile() {\n\t\treturn DefaultProps.TEXTURE_BLOCKS;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex(ForgeDirection direction) {\n\t\tif (direction == ForgeDirection.UNKNOWN)\n\t\t\treturn baseTexture;\n\t\telse {\n\t\t\tint metadata = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);\n\n\t\t\tif (metadata == direction.ordinal())\n\t\t\t\treturn plainTexture;\n\t\t\telse\n\t\t\t\treturn baseTexture;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setPowerProvider(IPowerProvider provider) {\n\t\tpowerProvider = provider;\n\t}\n\n\t@Override\n\tpublic IPowerProvider getPowerProvider() {\n\t\treturn powerProvider;\n\t}\n\n\t@Override\n\tpublic void doWork() {\n\t\tif (powerProvider.getEnergyStored() <= 0)\n\t\t\treturn;\n\n\t\tWorld w = worldObj;\n\n\t\tint meta = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);\n\n\t\tif (meta > 5)\n\t\t\treturn;\n\n\t\tPosition pos = new Position(xCoord, yCoord, zCoord, ForgeDirection.getOrientation(meta));\n\t\tpos.moveForwards(1);\n\t\tTileEntity tile = w.getBlockTileEntity((int) pos.x, (int) pos.y, (int) pos.z);\n\n\t\tif (tile instanceof IInventory) {\n\t\t\tif (!PipeManager.canExtractItems(this, w, (int) pos.x, (int) pos.y, (int) pos.z))\n\t\t\t\treturn;\n\n\t\t\tIInventory inventory = (IInventory) tile;\n\n\t\t\tItemStack[] extracted = checkExtract(inventory, true, pos.orientation.getOpposite());\n\t\t\tif (extracted == null)\n\t\t\t\treturn;\n\n\t\t\tfor (ItemStack stack : extracted) {\n\t\t\t\tif (stack == null || stack.stackSize == 0) {\n\t\t\t\t\tpowerProvider.useEnergy(1, 1, false);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPosition entityPos = new Position(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5, pos.orientation.getOpposite());\n\n\t\t\t\tentityPos.moveForwards(0.6);\n\n\t\t\t\tIPipedItem entity = new EntityPassiveItem(w, entityPos.x, entityPos.y, entityPos.z, stack);\n\n\t\t\t\t((PipeTransportItems) transport).entityEntering(entity, entityPos.orientation);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the itemstack that can be if something can be extracted from this inventory, null if none. On certain cases, the extractable slot depends on the\n\t * position of the pipe.\n\t */\n\tpublic ItemStack[] checkExtract(IInventory inventory, boolean doRemove, ForgeDirection from) {\n\n\t\t// / ISPECIALINVENTORY\n\t\tif (inventory instanceof ISpecialInventory) {\n\t\t\tItemStack[] stacks = ((ISpecialInventory) inventory).extractItem(doRemove, from, (int) powerProvider.getEnergyStored());\n\t\t\tif (stacks != null && doRemove) {\n\t\t\t\tfor (ItemStack stack : stacks) {\n\t\t\t\t\tif (stack != null) {\n\t\t\t\t\t\tpowerProvider.useEnergy(stack.stackSize, stack.stackSize, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stacks;\n\t\t}\n\n\t\tif (inventory instanceof ISidedInventory) {\n\t\t\tISidedInventory sidedInv = (ISidedInventory) inventory;\n\n\t\t\tint first = sidedInv.getStartInventorySide(from);\n\t\t\tint last = first + sidedInv.getSizeInventorySide(from) - 1;\n\n\t\t\tIInventory inv = Utils.getInventory(inventory);\n\n\t\t\tItemStack result = checkExtractGeneric(inv, doRemove, from, first, last);\n\n\t\t\tif (result != null)\n\t\t\t\treturn new ItemStack[] { result };\n\t\t} else if (inventory.getSizeInventory() == 2) {\n\t\t\t// This is an input-output inventory\n\n\t\t\tint slotIndex = 0;\n\n\t\t\tif (from == ForgeDirection.DOWN || from == ForgeDirection.UP) {\n\t\t\t\tslotIndex = 0;\n\t\t\t} else {\n\t\t\t\tslotIndex = 1;\n\t\t\t}\n\n\t\t\tItemStack slot = inventory.getStackInSlot(slotIndex);\n\n\t\t\tif (slot != null && slot.stackSize > 0) {\n\t\t\t\tif (doRemove)\n\t\t\t\t\treturn new ItemStack[] { inventory.decrStackSize(slotIndex, (int) powerProvider.useEnergy(1, slot.stackSize, true)) };\n\t\t\t\telse\n\t\t\t\t\treturn new ItemStack[] { slot };\n\t\t\t}\n\t\t} else if (inventory.getSizeInventory() == 3) {\n\t\t\t// This is a furnace-like inventory\n\n\t\t\tint slotIndex = 0;\n\n\t\t\tif (from == ForgeDirection.UP) {\n\t\t\t\tslotIndex = 0;\n\t\t\t} else if (from == ForgeDirection.DOWN) {\n\t\t\t\tslotIndex = 1;\n\t\t\t} else {\n\t\t\t\tslotIndex = 2;\n\t\t\t}\n\n\t\t\tItemStack slot = inventory.getStackInSlot(slotIndex);\n\n\t\t\tif (slot != null && slot.stackSize > 0) {\n\t\t\t\tif (doRemove)\n\t\t\t\t\treturn new ItemStack[] { inventory.decrStackSize(slotIndex, (int) powerProvider.useEnergy(1, slot.stackSize, true)) };\n\t\t\t\telse\n\t\t\t\t\treturn new ItemStack[] { slot };\n\t\t\t}\n\t\t} else {\n\t\t\t// This is a generic inventory\n\t\t\tIInventory inv = Utils.getInventory(inventory);\n\n\t\t\tItemStack result = checkExtractGeneric(inv, doRemove, from, 0, inv.getSizeInventory() - 1);\n\n\t\t\tif (result != null)\n\t\t\t\treturn new ItemStack[] { result };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int start, int stop) {\n\t\tfor (int k = start; k <= stop; ++k) {\n\t\t\tItemStack slot = inventory.getStackInSlot(k);\n\n\t\t\tif (slot != null && slot.stackSize > 0) {\n\t\t\t\tif (doRemove) {\n\t\t\t\t\treturn inventory.decrStackSize(k, (int) powerProvider.useEnergy(1, slot.stackSize, true));\n\t\t\t\t} else {\n\t\t\t\t\treturn slot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic int powerRequest() {\n\t\treturn getPowerProvider().getMaxEnergyReceived();\n\t}\n\n\t@Override\n\tpublic boolean canConnectRedstone() {\n\t\tif (PowerFramework.currentFramework instanceof RedstonePowerFramework)\n\t\t\treturn true;\n\t\treturn super.canConnectRedstone();\n\t}\n}\n
===================================================================
--- ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsWood.java	(date 1359853860000)
+++ ../../GitHub/BuildCraft/common/buildcraft/transport/pipes/PipeItemsWood.java	(revision )
@@ -27,6 +27,8 @@
 import buildcraft.core.utils.Utils;
 import buildcraft.transport.Pipe;
 import buildcraft.transport.PipeTransportItems;
+import net.minecraftforge.inventory.IInventoryHandler;
+import net.minecraftforge.inventory.InventoryUtils;
 
 public class PipeItemsWood extends Pipe implements IPowerReceptor {
 
@@ -208,14 +210,15 @@
 	}
 
 	public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int start, int stop) {
+		IInventoryHandler handler = InventoryUtils.getInventoryHandler(inventory);
 		for (int k = start; k <= stop; ++k) {
-			ItemStack slot = inventory.getStackInSlot(k);
-
-			if (slot != null && slot.stackSize > 0) {
+			int count = handler.getItemCountInSlot(inventory, k);
+			if (count > 0) {
 				if (doRemove) {
-					return inventory.decrStackSize(k, (int) powerProvider.useEnergy(1, slot.stackSize, true));
+					powerProvider.useEnergy(1, count, true);
+					return handler.takeItemFromInventory(inventory, from);
 				} else {
-					return slot;
+					return inventory.getStackInSlot(k);
 				}
 			}
 		}
